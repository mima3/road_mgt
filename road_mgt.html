<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
  <title>路線状況表示</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="js/leaflet-0.7.3/leaflet.css" />
  <link rel="stylesheet" href="js/jquery/jquery-ui.min.css" type="text/css" />
  <link rel="stylesheet" href="js/select2/select2.css" type="text/css" />
  <link rel="stylesheet" type="text/css" href="js/dc.js/dc.css"/>
  <link rel="stylesheet" href="base.css" type="text/css" />
  <script type="text/javascript" src="js/async/lib/async.js"></script>
  <script type="text/javascript" src="js/jquery/jquery-1.11.1.min.js"></script>
  <script type="text/javascript" src="js/jquery/jquery-ui-1.10.4.min.js"></script>
  <script type="text/javascript" src="js/d3/d3.min.js"></script>
  <script type="text/javascript" src="js/blockui/jquery.blockUI.js"></script>
  <script type="text/javascript" src="js/select2/select2.min.js"></script> 
  <script type="text/javascript" src="js/crossfilter/crossfilter.js"></script>
  <script type="text/javascript" src="js/dc.js/dc.js"></script>
  <script src="js/leaflet-0.7.3/leaflet.js"></script>
  <script type="text/javascript" src="js/util.js"></script>


</head>
<body>
    <div id="header" >
      <h1>路線状況表示</h1>
    </div>
  <div id="contents">
    
    <div id = "left_area">
      <div>
        地図の種類:
        <select id="selMap">
          <option value="OpenStreetMap" selected>OpenStreetMap</option>
          <option value="chiriin">地理院地図</option>
        </select>
      </div>
      <div>
        8分の1地域メッシュ：
        <select id="selMesh">
           <option value="" selected>非表示</option>
           <option value="iri_avg">IRIの平均</option>
           <option value="step_avg">段差の平均</option>
           <option value="rutting_amount_avg">わだち掘れ深さの平均</option>
           <option value="cracking_rate_avg">ひび割れ率の平均</option>
           <option value="subsidence_and_puddle_avg">沈下・水たまりの平均</option>
           <option value="pothole_num_sum">ポットホール数の合計</option>
           <option value="patching_num_sum">パッチング数の合計</option>
        </select>
      </div>
    </div>
    <div id = "main_area">
      <div id="map" style="width: 100%; height: 600px"></div>
    </div>
    <div  style="clear:both;"></div>
    <p>このアプリケーションは、以下の著作物を改変して利用しています。</p>
    <p>【路面状況データ】【道路緒元データ】、クリエイティブ・コモンズ・ライセンス 表示 2.1 日本（http://creativecommons.org/licenses/by/2.1/jp/）、オープンデータ・アプリコンテスト利用規約（<a href="http://micrms.force.com/terms#rules" target="_blank">http://micrms.force.com/terms#rules</a>）</p>
  </div>
<script type="text/javascript">
$(function() {
  //Leaflet初期設定
  var map = L.map('map').setView([35.607267, 140.106291], 13);
   
  //Leafletに用意されたsvgを使う 
  map._initPathRoot();
  
  //Tile Map Serviceの指定    
  /*
  L.tileLayer(
      'http://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
      attribution: '&copy; ' + mapLink + ' Contributors',
      maxZoom: 18,
  }).addTo(map);
  */

  var tileLayer = null;
  function changeTileLayer(v) {
    if (tileLayer) {
      map.removeLayer(tileLayer);
    }
    var mapDict = {
      'OpenStreetMap': {
        url : 'https://{s}.tiles.mapbox.com/v3/{id}/{z}/{x}/{y}.png',
        attribution : 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
                      '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
                      'Imagery c <a href="http://mapbox.com">Mapbox</a>',
        id : 'examples.map-0l53fhk2'
      },
      'chiriin': {
        url : 'http://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png',
        attribution : '<a href="http://portal.cyberjapan.jp/help/termsofuse.html" target="_blank">国土地理院</a>',
        id : null
      }
    }
    tileLayer = L.tileLayer(mapDict[v].url, {
      maxZoom: 18,
      minZoom: 10,
      attribution: mapDict[v].attribution,
      id: mapDict[v].id
    }).addTo(map);
  }
  changeTileLayer('OpenStreetMap');

  map.on('click', function(e){
    console.log(e);
  });

  $('#selMap').select2({
    width: 'resolve' ,
    dropdownAutoWidth: true
  });
  $('#selMap').change(function() {
    changeTileLayer($('#selMap').val());
  });

  function getDataByRange(data_type, lat_start, lon_start, lat_end, lon_end, callback) {
    var offset = 0;
    var limit = 300;
    var obj = {};

    function loadRoadOffset(lat_start, lon_start, lat_end, lon_end, offset, limit, obj, cb) {

      console.log(offset, limit);
      $.ajax({
        type : 'GET',
        url : 'http://roadmgt.herokuapp.com/api/v1/datapoints',
        cache: true , //, cacheをfalseにするとエラーになる。おそらく変なパラメータを無視するのでなく、はじいている
        data : {
          data_type : data_type,
          lat_start  : lat_start,
          lon_start : lon_start,
          lat_end  : lat_end,
          lon_end  : lon_end,
          offset : offset,
          limit : limit
        },
        success : function (data) {
          console.log(data);
          var obj = {};
          var root = data.documentElement;
          var attrs = root.attributes;
          var records = root.childNodes;
          for(var i=0; i<records.length; i++){
            if(records[i].nodeName.match(/rdf:Description/i)){
              var s = records[i].attributes["rdf:about"].value;
              var props = records[i].childNodes;
              for(var j=0; j<props.length; j++){
                if(props[j].nodeType == 1){
                  var p = props[j].nodeName;
                  var o = props[j].textContent;
                  if (!obj[s]) {
                    obj[s] = {};
                  }
                  if (obj[s][p]) {
                    if (!Array.isArray(obj[s][p])) {
                      var tmp = arys[s][p];
                      obj[s][p] = [];
                      obj[s][p].push(tmp);
                    }
                    obj[s][p].push(o);
                  } else {
                    obj[s][p] = o;
                  }
                }
              }
            }
          }
          //if (offset > 600) {
          //  cb(null , obj);
          //  return;
          //}
          loadRoadOffset(lat_start, lon_start, lat_end, lon_end, offset + limit, limit, obj, cb);
        },
        'error' :  function(xhr, textStatus, error) {
          console.log(xhr);
          var err = xhr.responseText;
          if (err == '404 notFound') {
            cb(null , obj);
          } else {
            cb(err , null);
          }
        }
      });
    }
    loadRoadOffset(lat_start, lon_start, lat_end, lon_end, offset, limit, obj, function(err, res) {
      callback(err, res);
    });
  }

  var latlngBounds = map.getBounds();
  var latlngBounds = map.getBounds();
  var swLatlng = latlngBounds.getSouthWest();
  var swlat = swLatlng.lat;
  var swlng = swLatlng.lng;
  var neLatlng = latlngBounds.getNorthEast();
  var nelat = neLatlng.lat;
  var nelng = neLatlng.lng;

  var svg = d3.select(map.getPanes().overlayPane).append("svg");
  var g = svg.append("g").attr("class", "leaflet-zoom-hide");
  var transform = d3.geo.transform({point: projectPoint});
  var path = d3.geo.path().projection(transform);
  console.log('path', path);
  //位置→座標変換
  function projectPoint(x, y) {
    var point = map.latLngToLayerPoint(new L.LatLng(y, x));
    this.stream.point(point.x, point.y);
  }


  console.log(swlat, swlng, nelat, nelng);
  function showBlockUI() {
    $.blockUI(
      { 
        message: '<img src="img/loading.gif" />Loading...',
        css: { 
          border: 'none', 
          padding: '15px', 
          backgroundColor: '#444', 
          '-webkit-border-radius': '10px', 
          '-moz-border-radius': '10px', 
          opacity: .5, 
          color: '#fff' 
        } 
      }
    );
  }
  showBlockUI();


  getDataByRange('road-master', swlat, swlng, nelat, nelng, function(err, data) {
    $.unblockUI();
    console.log('loadRoad', err, data);
    if (err) {
      return;
    }
    features = [];

    for (var k in data) {
      var f = false;
      for (var i = 0; i < features.length; ++i) {
        if (features[i].geometry.coordinates.lenght < 2) {
          continue;
        }
        if (!data[k]['rm:long_start'] || !data[k]['rm:long_end'] ||
            !data[k]['rm:lat_start'] || !data[k]['rm:lat_end']
        ) {
          // 座標がないデータは無視
          f = true;
          break;
        }
        // data[k]の開始点が、すでに登録済みのポイントの終了点と同じなら末尾に付与する
        if (data[k]['rm:long_start'] == features[i].geometry.coordinates[features[i].geometry.coordinates.length - 1][0] &&
            data[k]['rm:lat_start'] == features[i].geometry.coordinates[features[i].geometry.coordinates.length - 1][1]) {
          features[i].geometry.coordinates.push(
            [data[k]['rm:long_end'], data[k]['rm:lat_end']]
          );
          f = true;
          break;
        }

        // data[k]の終了点が、すでに登録済みのポイントの開始点と同じなら先頭に付与する
        if (data[k]['rm:long_end'] == features[i].geometry.coordinates[0][0] &&
            data[k]['rm:lat_end'] == features[i].geometry.coordinates[0][1]) {
          features[i].geometry.coordinates.splice(0, 0, 
            [data[k]['rm:long_start'], data[k]['rm:lat_start']]
          );
          f = true;
          break;
        }
      }
      if (!f) {
        // どこのデータにも入らない。
        features.push({
          geometry : {
            coordinates : [
              [data[k]['rm:long_start'], data[k]['rm:lat_start']],
              [data[k]['rm:long_end'], data[k]['rm:lat_end']]
            ],
            type : 'LineString'
          },
          properties: {},
          type : 'Feature'
        });
      }
    }

    function compressionPath(features) {
      var before = features.length;
      for (var i = 0; i < features.length; ++i) {
        for (var j = features.length -1; i < j; --j) {
          var f1Start = features[i].geometry.coordinates[0];
          var f1End = features[i].geometry.coordinates[features[i].geometry.coordinates.length-1];

          var f2Start = features[j].geometry.coordinates[0];
          var f2End = features[j].geometry.coordinates[features[j].geometry.coordinates.length-1];

          // f1の開始点がf2の終端と一致する場合、f1の前にf2がある
          if (f1Start[0] == f2End[0] && f1Start[1] == f2End[1]) {
            features[i].geometry.coordinates = features[j].geometry.coordinates.concat(features[i].geometry.coordinates);
            features.splice(j, 1);
            break;
          }
          // f1の終了点がf2の開始点と一致する場合、f1の後にf2がある
          if (f1End[0] == f2Start[0] && f1End[1] == f2Start[1]) {
            features[i].geometry.coordinates = features[i].geometry.coordinates.concat(features[j].geometry.coordinates);
            features.splice(j, 1);
            break;
          }
        }
      }
      if (features.length == before) {
        return;
      }
      compressionPath(features);
    }

    console.log(features.length);
    compressionPath(features);
    console.log(features.length);


    var d3_features = g.selectAll('path')
      .data(features)
      .enter()
      .append('path')
      .attr('class', 'road')
      .attr('id', function(d, i) {
        return 'road_' + i;
      });

    var d3_marker = g.selectAll('circle')
      .data(features)
      .enter()
      .append('circle')
      .attr('class', 'marker');

    map.on('viewreset', update);

    update();

    
    function update() {
      //SVG要素をleafletのマップレイヤーにフィットさせる
      console.log('update');
      var bounds = path.bounds({type:'FeatureCollection', 'features': features});

      var topLeft = bounds[0];
      var bottomRight = bounds[1];

      svg.attr({
          'width': bottomRight[0] - topLeft[0],
          'height': bottomRight[1] - topLeft[1]
        })
        .style({
          'left': topLeft[0] + 'px',
          'top': topLeft[1] + 'px'
        })
    
      g.attr('transform', 'translate(' + -topLeft[0] + ',' + -topLeft[1] + ')');
    
      // path要素（地形)更新
      d3_features
        .attr('d', path)
        .attr({
          'fill-opacity': 0.4,
          'fill': 'none',
          'stroke': 'red'
        });

      function setMarkerTransition(sel) {
      }
      d3_marker.attr('d', path)
        .attr({
          'r': 2,
          'fill': 'blue'
        })
      setMarkerTransition();

      function setMarkerTransition() {
        d3_marker.transition()
          .duration(1500)
          .each('end', setMarkerTransition)
          .ease("linear")
          .attrTween("transform", function (d, i) {
            var node = g.select('#road_' + i).node();
            return function (t) {
              var p = node.getPointAtLength(node.getTotalLength()*t);
              return "translate(" + [p.x, p.y] + ")";
            }
          });
      }
      
      drawMesh();
    } 
  });
  

  var surfaces = [];
  var measlocale = [];
  /*
  getDataByRange('road-surface', swlat, swlng, nelat, nelng, function(err, data) {
    console.log('road-surface', err, data);
    for (var k in data) {
      var circle = L.circle([parseFloat(data[k]['geo:lat']), parseFloat(data[k]['geo:long'])], 5, {
        color: 'green',
         fillColor: '#f03',
       fillOpacity: 0.5
      }).addTo(map);
      circle.bindPopup("I am a circle.");
      surfaces.push(circle);
    }
  });

  getDataByRange('meas-locale', swlat, swlng, nelat, nelng, function(err, data) {
    console.log('meas-locale', err, data);
    for (var k in data) {
      var circle = L.circle([parseFloat(data[k]['geo:lat']), parseFloat(data[k]['geo:long'])], 5, {
        color: 'blue',
         fillColor: '#f03',
       fillOpacity: 0.5
      }).addTo(map);
      circle.bindPopup("I am a circle.");
      measlocale.push(circle);
    }
  });
  */


  var meshSvg;
  var meshData = [];
  var colorScale = d3.scale.linear().domain([0, 100]).range([0.0, 0.8]);
  var meshLoadCallbackEvent = null;

  $('#selMesh').select2({
    width: 'resolve' ,
    dropdownAutoWidth: true
  });
  $('#selMesh').change(function() {
    function setupMesh() {
      var max = 0;
      var attr = $('#selMesh').val();
      for (var i = 0; i < meshData.length; ++i) {
        var v = meshData[i][attr];
        if (max < v) {
          max = v;
        }
      }
      colorScale = d3.scale.linear().domain([0, max]).range([0.0, 0.8]);
      drawMesh();
    }
    if (meshData.length==0) {
      showBlockUI();
      meshLoadCallbackEvent = function() {
        setupMesh();
        meshLoadCallbackEvent = null;
        $.unblockUI();
      }
      return;
    }
    else {
      setupMesh();
    }
  });

  function drawMesh() {
    if (!meshSvg) {
      return;
    }

    meshSvg.attr('x', function(d, i) {
        var pt =  map.latLngToLayerPoint(new L.LatLng(d.w, d.s));
        return pt.x;
      })
      .attr('y', function(d, i) {
        var pt =  map.latLngToLayerPoint(new L.LatLng(d.w, d.s));
        return pt.y;
      })
      .attr('width', function(d, i) {
        var pt1 =  map.latLngToLayerPoint(new L.LatLng(d.w, d.s));
        var pt2 =  map.latLngToLayerPoint(new L.LatLng(d.e, d.n));
        return Math.abs(pt2.x - pt1.x);
      })
      .attr('height', function(d, i) {
        var pt1 =  map.latLngToLayerPoint(new L.LatLng(d.w, d.s));
        var pt2 =  map.latLngToLayerPoint(new L.LatLng(d.e, d.n));
        return Math.abs(pt2.y - pt1.y);
      })
      .attr('fill-opacity', function(d) {
        var v = $('#selMesh').val();
        if (!v) {
          return 0;
        }
        return colorScale(d[v]);
      })
      .attr('fill' , '#FFFF00');
  }
  $.ajax({
    type : 'GET',
    url : '/road_mgt/json/get_road_surface_mesh',
    cache: false,
    data : {},
    success : function (data) {
      meshData = data;
      meshSvg = g.selectAll('rect')
        .data(data)
        .enter()
        .append('rect');

      if (meshLoadCallbackEvent) {
        meshLoadCallbackEvent();
      }
    },
    'error' :  function(xhr, textStatus, error) {
      console.log(xhr);
    }
  });


});
</script>
</body>
</html>
